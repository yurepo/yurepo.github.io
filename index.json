[{"content":"Hugo 添加 Google Analytics 4 筆記 前言 最近HUGO更新了0.82.0版本，此版本對比上一版本改進不大，對我來說，最有感的應該是增加了內置Google Analytics 4的支持，也就是可以使用G-開頭的評估ID而不是UA-開頭的追蹤ID，那首先就來回顧一下Universal Analytics(GA3)與Google Analytics 4。\nGA4 x GA3 GA3 (Universal Analytics) UA於2012年10月發布，在上一代GA中，主要以網站會話(session)以及網站頁面為主，資料的來源主要從三個管道收集\n HTTP請求 瀏覽器/系統資訊 第一方Cookie  其中，我們最容易見到的是帶有utm開頭參數的連結，範例如下\n範例： http://example.com/?utm_source=active%20users\u0026amp;utm_medium=email\u0026amp;utm_campaign=feature...\n這種分享連結後方都會添加一些utm開頭之參數，這個utm參數會記錄其來源、媒介、名稱，等到使用者造訪網站時，在網站上嵌入的UA會去收集這些參數並發送至Google Analytics，讓網站管理者檢視、分析成效。\n上方的範例僅限於使用者是被哪個社群網站、哪個廣告以及從哪個來源(e.g. email、app)吸引而進入網站，那如何去收集使用者在網站內部的活動呢?\nUA擁有許多不同匹配去收集使用者在網站內部的活動，這邊介紹最常見的三種：\n 網頁瀏覽匹配: 使用者載入嵌有UA的頁面時便會觸發此匹配，是最常觸發的操作。 事件匹配: 追蹤使用者在網站上特定元素的每次互動，例如：開啟的網址、播放的影片等。 交易匹配: 傳送電子商務購買的相關資料，例如：售出的產品、交易ID、庫存計量單位(SKU)等等。  除上述三種之外也有許多其他匹配，像是社交匹配、網頁操作時間匹配等\nGA4 (Google Analytics 4) GA4於2020年10月16日發布，在這一代GA中，主要採用以事件(event-based)的方式去收集資料，相較於上一代GA3，GA4提供了更彈性、更智慧、跨平台的數據蒐集方法。\nGA4與GA3同樣都使用gtag.js向Google Analytics發送事件數據。\n在以往的GA3，如果想要評估App端上的使用數據，必須使用Google Analytics for Firebase或是Google Analytics APP view建立不同的GA資源(Property)，想要結合網頁端及App端的使用數據相對來說是較不容易的。\nGA4 整合了 Web 端及 APP 端的資料，並可以將其結合在一起進行分析，也可以單獨蒐集網站上的資料。\nGA4默認提供了六種增強性評估\n 網頁瀏覽 捲動 外連點擊 站內搜尋 影片參與 檔案下載  若要詳細了解GA4的功能及比較，可至【一表看懂】新版 GA4 與舊版 GA 差在哪裡？新舊版本功能比較懶人包！\nTL;DR：新版GA4相較於上一代GA3更彈性、更智慧(後臺方面)、跨平台，但GA3上有的功能並不一定在GA4上可以找到替代品，若是打算由GA3遷移到GA4，可保留GA3和GA4兩者。不過對於Hugo使用者來說，不管是選擇GA3或是GA4都應該可以達成目的。\n如何在 Hugo 設定 GA4 接下來進入到正題，如何在新版Hugo設定GA4呢?\n其實在新版Hugo設定GA4與設定UA並無不同\n第一步，設定config.yml 首先在部落格根目錄的config.yml必須加上\ngoogleAnalytics: \u0026lt;GA4_評估_ID\u0026gt; (取得GA4評估ID請至Google Analytics，這邊並不贅述)\n第二步，向主題上新增GA4模板 並且在您主題的模板(template)上新增\n\u0026lt;!-- Add GA4 support --\u0026gt; {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }} (記得這段應在HTML中的\u0026lt;head\u0026gt;區段中增加)，以我目前使用的主題PaperMod為範例，應在...\\themes\\PaperMod\\layouts\\partials\\head.html中添加)\n參考資料 Google Analytics - Internal Templates\n【一表看懂】新版 GA4 與舊版 GA 差在哪裡？新舊版本功能比較懶人包！\n什麼是UTM？如何使用UTM追蹤成效、數據與流量？\n透過自訂網址收集廣告活動資料\n跟踪代码概览\nHow Google Analytics collects data (5:39)\n","permalink":"https://yurepo.github.io/2021/03/hugo-%E6%B7%BB%E5%8A%A0-google-analytics-4-%E7%AD%86%E8%A8%98/","summary":"Hugo 添加 Google Analytics 4 筆記 前言 最近HUGO更新了0.82.0版本，此版本對比上一版本改進不大，對我來說，最有感的應該是增加了內置Google Analytics 4的支持，也就是可以使用G-開頭的評估ID而不是UA-開頭的追蹤ID，那首先就來回顧一下Universal Analytics(GA3)與Google Analytics 4。\nGA4 x GA3 GA3 (Universal Analytics) UA於2012年10月發布，在上一代GA中，主要以網站會話(session)以及網站頁面為主，資料的來源主要從三個管道收集\n HTTP請求 瀏覽器/系統資訊 第一方Cookie  其中，我們最容易見到的是帶有utm開頭參數的連結，範例如下\n範例： http://example.com/?utm_source=active%20users\u0026amp;utm_medium=email\u0026amp;utm_campaign=feature...\n這種分享連結後方都會添加一些utm開頭之參數，這個utm參數會記錄其來源、媒介、名稱，等到使用者造訪網站時，在網站上嵌入的UA會去收集這些參數並發送至Google Analytics，讓網站管理者檢視、分析成效。\n上方的範例僅限於使用者是被哪個社群網站、哪個廣告以及從哪個來源(e.g. email、app)吸引而進入網站，那如何去收集使用者在網站內部的活動呢?\nUA擁有許多不同匹配去收集使用者在網站內部的活動，這邊介紹最常見的三種：\n 網頁瀏覽匹配: 使用者載入嵌有UA的頁面時便會觸發此匹配，是最常觸發的操作。 事件匹配: 追蹤使用者在網站上特定元素的每次互動，例如：開啟的網址、播放的影片等。 交易匹配: 傳送電子商務購買的相關資料，例如：售出的產品、交易ID、庫存計量單位(SKU)等等。  除上述三種之外也有許多其他匹配，像是社交匹配、網頁操作時間匹配等\nGA4 (Google Analytics 4) GA4於2020年10月16日發布，在這一代GA中，主要採用以事件(event-based)的方式去收集資料，相較於上一代GA3，GA4提供了更彈性、更智慧、跨平台的數據蒐集方法。\nGA4與GA3同樣都使用gtag.js向Google Analytics發送事件數據。\n在以往的GA3，如果想要評估App端上的使用數據，必須使用Google Analytics for Firebase或是Google Analytics APP view建立不同的GA資源(Property)，想要結合網頁端及App端的使用數據相對來說是較不容易的。\nGA4 整合了 Web 端及 APP 端的資料，並可以將其結合在一起進行分析，也可以單獨蒐集網站上的資料。\nGA4默認提供了六種增強性評估\n 網頁瀏覽 捲動 外連點擊 站內搜尋 影片參與 檔案下載  若要詳細了解GA4的功能及比較，可至【一表看懂】新版 GA4 與舊版 GA 差在哪裡？新舊版本功能比較懶人包！","title":"Hugo 添加 Google Analytics 4 筆記"},{"content":"手把手教學: 將Hugo部落格佈署到Github上 前言 最近將以前的部落格從Hexo遷移到Hugo上了，不得不說Hugo在產生靜態頁面的速度比起Hexo來說快了很多，得益於Hexo跟Hugo都是使用Markdown文件的原因，在兩者之間進行遷移是非常容易的，今天就來為自己做個筆記，希望大家看了這篇文章後，沒有部落格的都可以嘗試建立一下自己的部落格。\n教學開始 這邊安裝的Hugo版本為hugo v0.81.0，環境為Win10 20H2 x64，使用的工具為git與chocolatey，若是macOS，則可以使用Homebrew，Linux的部分則在這邊下載\n第一步，安裝Hugo 這邊主要就照著官方的快速開始建立部落格，因為官方已經寫的足夠清楚了，所以在此處僅寫Windows版本的安裝過程\n如果要安裝普通版本的Hugo，請使用以下指令\nchoco install hugo -confirm 如果要安裝Sass/SCSS版本的，請使用以下指令(有些主題會要求需要hugo-extended版本)\nchoco install hugo-extended -confirm 第二步，建立部落格 安裝完Hugo後，可以使用hugo version確認是否安裝成功。\n安裝成功後，在你想要建立部落格的資料夾內打開powershell，並打以下指令即可建立。\nhugo new site \u0026lt;資料夾名稱\u0026gt; 出現以下畫面就說明安裝成功了!\n第三步，添加主題 接下來到官方的主題網站挑選您喜歡的主題，此範例使用ananke主題。\n只需要打以下指令就可以新增主題了\ncd \u0026lt;資料夾名稱\u0026gt; git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 接著修改config.toml文件，詳細的設定方式可以參照官網\n# 基本設置 baseURL = \u0026#34;\u0026lt;網址\u0026gt;\u0026#34; title = \u0026#34;\u0026lt;標題\u0026gt;\u0026#34; languageCode = \u0026#34;en-us\u0026#34; # 主題設置 theme=\u0026#34;ananke\u0026#34; # 連結設置 [permalinks] posts = \u0026#34;/:year/:month/:title/\u0026#34; 第四步，建立第一篇貼文 接著輸入以下指令建立第一篇貼文\nhugo new posts/hello-world.md 接著打開Markdown編輯工具(e.g. Visual Studio Code)，寫點簡單的文章並存檔。\n--- title: \u0026#34;Hello World\u0026#34; date: 2021-03-21T21:46:28+08:00 draft: false --- # Hello world 我在`2021-03-21`建立了第一篇文章。 第五步，預覽網站 就跟Hexo一樣，Hugo也提供了本地伺服器的功能，僅需在部落格資料夾下使用powershell或cmd打hugo server -D就可以在本地端預覽網站，預設網址為: http://localhost:1313/\n第六步，將Hugo部落格放到Github上 接下來，在github建立一個存放網站用的Repository，並將其命名為\n\u0026lt;username\u0026gt;.github.io\n註: username必須是您在Github上的的使用者名稱\n接下來，在部落格資料夾下建立一條gh-pages分支(branch)，這個分支是用來展示靜態頁面的，我們稍後會使用Github Action將主分支的內容透過自動化部署的方式，自動產生靜態文件到gh-pages分支上。\n# 加入所有檔案 git add . # 新增commit內容 git commit -m \u0026#34;init blog\u0026#34; # 新增main分支 git branch -M main # 新增遠端版本庫 git remote add origin https://github.com/\u0026lt;使用者名稱\u0026gt;/\u0026lt;使用者名稱\u0026gt;.github.io.git # 將部落格內容上傳到remote git push -u origin main # 新增gh-pages孤兒分支 git checkout --orphan gh-pages # 砍掉gh-pages分支的所有檔案 git rm -rf . # 新增一個README.md檔 echo \u0026#34;gh-pages\u0026#34; \u0026gt; \u0026#34;README.md\u0026#34; # 加入所有檔案 git add . # 新增commit內容 git commit -m \u0026#34;init gh-pages branch\u0026#34; # 將分支內容上傳到remote git push -u origin gh-pages # 切換到main分支 git checkout main 將上面的指令打完後，照理來講會出現兩個分支，一個叫做main，另一個叫做gh-pages\n第七步，設定Github Action進行自動化部署 要怎麼將main分支上的hugo檔案，自動化部署到gh-pages分支上呢?\n前置作業 首先我們先到這個頁面去取得我們的Personal Access Token (等等會用到)。\n將workflow那一項打勾之後到頁面最下方按下Generate Token\n將產生出來的令牌先複製起來\n接下來到你存放Hugo部落格的Repository \u0026gt; Settings \u0026gt; Secret \u0026gt; New repository secret新增你剛取得的令牌\n將Name取為HUGO_DEPLOY_TOKEN，Value設定為剛取得的令牌，按下Add Secret\n至此前置動作完成，接下來開始設定workflow\n設定workflow 我們將會參考此文的workflow文件去設定Github Action。\n首先，進到Github Action頁面，並點選set up a workflow your self\n將下面的文件貼上並修改一些設定(e.g. name)\nname: \u0026lt;workflow名稱\u0026gt; on: push: branches: - main  # 當main分支有push操作時 jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # 找尋Hugo主題(true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.81.0\u0026#39; # hugo 版本 # extended: true # 如果是使用extended版本的務必取消註解。 - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.HUGO_DEPLOY_TOKEN }} PUBLISH_BRANCH: gh-pages  # 推送到 gh-pages 分支 PUBLISH_DIR: ./public  # hugo 生成的目錄 commit_message: ${{ github.event.head_commit.message }} 打好後按下右上角的Start commit儲存完workflow的設定文件後就可以在Repository的Action頁面看到workflow的執行狀態\n若執行狀態為綠色打勾即為部署成功!\n第八步，部落格建置 最後一步，到你存放Hugo部落格的Repository \u0026gt; Settings內，將GitHub Pages的分支改為gh-pages就大功告成了!\n之後新增文章只需要三個步驟\n 建立新的貼文 撰寫貼文 上傳整個hugo文件夾到github  剩下的靜態文件產生會由Github Action幫你處理並自動幫你部署到gh-pages分支上。\n結語 至此只需要簡單幾個步驟就可以建立Hugo網站並將網站Host到Github Pages上了，希望可以幫助到想要建立自己部落格的人！\n","permalink":"https://yurepo.github.io/2021/03/%E5%A6%82%E4%BD%95%E5%B0%87hugo%E9%83%A8%E8%90%BD%E6%A0%BC%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/","summary":"手把手教學: 將Hugo部落格佈署到Github上 前言 最近將以前的部落格從Hexo遷移到Hugo上了，不得不說Hugo在產生靜態頁面的速度比起Hexo來說快了很多，得益於Hexo跟Hugo都是使用Markdown文件的原因，在兩者之間進行遷移是非常容易的，今天就來為自己做個筆記，希望大家看了這篇文章後，沒有部落格的都可以嘗試建立一下自己的部落格。\n教學開始 這邊安裝的Hugo版本為hugo v0.81.0，環境為Win10 20H2 x64，使用的工具為git與chocolatey，若是macOS，則可以使用Homebrew，Linux的部分則在這邊下載\n第一步，安裝Hugo 這邊主要就照著官方的快速開始建立部落格，因為官方已經寫的足夠清楚了，所以在此處僅寫Windows版本的安裝過程\n如果要安裝普通版本的Hugo，請使用以下指令\nchoco install hugo -confirm 如果要安裝Sass/SCSS版本的，請使用以下指令(有些主題會要求需要hugo-extended版本)\nchoco install hugo-extended -confirm 第二步，建立部落格 安裝完Hugo後，可以使用hugo version確認是否安裝成功。\n安裝成功後，在你想要建立部落格的資料夾內打開powershell，並打以下指令即可建立。\nhugo new site \u0026lt;資料夾名稱\u0026gt; 出現以下畫面就說明安裝成功了!\n第三步，添加主題 接下來到官方的主題網站挑選您喜歡的主題，此範例使用ananke主題。\n只需要打以下指令就可以新增主題了\ncd \u0026lt;資料夾名稱\u0026gt; git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 接著修改config.toml文件，詳細的設定方式可以參照官網\n# 基本設置 baseURL = \u0026#34;\u0026lt;網址\u0026gt;\u0026#34; title = \u0026#34;\u0026lt;標題\u0026gt;\u0026#34; languageCode = \u0026#34;en-us\u0026#34; # 主題設置 theme=\u0026#34;ananke\u0026#34; # 連結設置 [permalinks] posts = \u0026#34;/:year/:month/:title/\u0026#34; 第四步，建立第一篇貼文 接著輸入以下指令建立第一篇貼文\nhugo new posts/hello-world.md 接著打開Markdown編輯工具(e.g. Visual Studio Code)，寫點簡單的文章並存檔。","title":"如何將Hugo部落格部署到Github上?"},{"content":"令牌桶演算法實現 前言 這幾天將令牌桶限流演算法使用gin + redis實現了，主要來講是整個限流過程是如何運作的。\nGithub連結\n主要定義了四個文件\n   文件名 描述     dto.go 定義及宣告Ratelimiter的基本結構與核心Take()方法   err.go 定義了一些錯誤   ratelimiter.go 存放gin middleware中驗證的邏輯   script.go 存放 lua 腳本及 lua 腳本中輸入變數的結構    我們會將上次更新的時間與剩餘令牌的數量儲存在Redis中，而主要更新的邏輯會寫在script.go，這裡會發現整個操作Redis資料庫的邏輯是使用lua script去實作的，把多個操作Redis的指令包在lua script中，Redis會保證lua script中的多個操作會以Atomic的方式進行，這樣才可以保證每個操作之間不會有競爭情況(Race Condition)發生。 參考資料\n程式碼部分 Golang 接下來就進入到程式碼的部分 首先我定義了 RedisRateLimiter 結構\ndto.go\ntype RedisRateLimiter struct { context context.Context scriptSHA1 string client *redis.Client } 這邊將RedisRateLimiter的一些必須用到的變數包裝起來，包裝的變數型別包含了Redis客戶端、LUA Script SHA1(後續會使用evalsha調用已經讀進Redis腳本緩存的Lua script)、Goroutine context。\n這個Repository實現的演算法是Token Bucket演算法，不過也可以利用上述定義的結構去實現不同算法，例如：Leaky Bucket。\ndto.go\ntype TokenBucketRedisRateLimiter struct { RedisRateLimiter identifier string interval time.Duration maxRequest int } func (r *TokenBucketRedisRateLimiter) Take(request TokenBucketLuaRequest) *LimiterResponse { result, err := r.client.EvalSha( r.context, r.scriptSHA1, []string{request.valueKey, request.timestampKey}, request.limit, request.interval, request.batchSize, ).Result() if err != nil { return \u0026amp;LimiterResponse { status: false, remain: 0, err: err, } } else { data := result.([]interface{}) if len(data) != 2 { return \u0026amp;LimiterResponse{ status: false, remain: 0, err: ErrRedisError, } } return \u0026amp;LimiterResponse{ status: data[0] == nil, remain: data[1].(int64), err: nil, } } } 這邊的邏輯很簡單，就是透過Redis.Client執行存入的Lua Script，並回傳其執行結果，得益於Redis單線程的優點，使用Lua Script不會發生Race Condition。(因為執行Lua Script時，Redis是將Lua Script視為一個Atomic的操作。)\nratelimiter.go\nfunc (r *TokenBucketRedisRateLimiter) Middleware() gin.HandlerFunc { return func(context *gin.Context) { ip := context.ClientIP() if ip == \u0026#34;\u0026#34; { _ = context.AbortWithError(http.StatusInternalServerError, ErrIpNotRecognize) } request := TokenBucketLuaRequest{ valueKey: fmt.Sprintf(\u0026#34;%v_%v_Token\u0026#34;, r.identifier, ip), timestampKey: fmt.Sprintf(\u0026#34;%v_%v_Update_Time\u0026#34;, r.identifier, ip), limit: int64(r.maxRequest), interval: r.interval.Milliseconds(), batchSize: 1, } response := r.Take(request) if response.status { context.Writer.Header().Set(\u0026#34;X-RateLimit-Remaining\u0026#34;, strconv.FormatInt(response.remain, 10)) context.Writer.Header().Set(\u0026#34;X-RateLimit-Limit\u0026#34;, strconv.Itoa(r.maxRequest)) context.Next() } else { _ = context.AbortWithError(http.StatusTooManyRequests, TooManyRequest) } } } func NewRedisRateLimiter(ctx context.Context, identifier string,interval time.Duration, times int, redisClient *redis.Client) *TokenBucketRedisRateLimiter { script := TokenBucketLuaScript scriptSHA1 := fmt.Sprintf(\u0026#34;%x\u0026#34;, sha1.Sum([]byte(script))) if !redisClient.ScriptExists(ctx, scriptSHA1).Val()[0] { redisClient.ScriptLoad(ctx, script).Val() } return \u0026amp;TokenBucketRedisRateLimiter{ RedisRateLimiter: RedisRateLimiter{ context: ctx, scriptSHA1: scriptSHA1, client: redisClient, }, identifier: identifier, interval: interval, maxRequest: times, } } TokenBucketRedisRateLimiter傳入的變數意義\n   文件名 描述     RedisRateLimiter 傳入Redis客戶端及腳本sha1及Goroutine上下文   identifier 區別不同middleware的值，   interval 令牌過期時間   maxRequest 最大請求量    Middleware 運作步驟：\n 取得客戶端IP，若為空回傳500錯誤 建立要送到Lua腳本的請求. 調用Lua腳本並返回結果 若結果為未被拒絕(rejected: false)，設置回傳Header: X-RateLimit-Remaining及X-RateLimit-Limit，反之則回傳429錯誤。  Lua Script 最關鍵的Lua Script我們分幾個部分來看它。\n第一個部分： 傳入變數\n-- Request value local valueKey = KEYS[1] local timestampKey = KEYS[2] local limit = tonumber(ARGV[1]) local interval = tonumber(ARGV[2]) -- milliseconds local batchSize = math.max(tonumber(ARGV[3]), 0) 這邊做個表格簡單表示一下變數代表的意思\n   變數名 描述     valueKey 令牌數量   timestampKey 上次存取的時間戳(ms)   limit 最大令牌量   interval 令牌過期時間   batchSize 執行操作需要消耗的令牌量    Token Bucket 演算法是透過剩餘的令牌量去評估請求是否可以被執行，那這邊就會發現一個問題了，Redis只儲存了上次令牌剩餘量為多少，所以必須透過timestampKey求得當前剩餘量，計算方式應為：上次剩餘令牌 + 從上次存取時間到目前時間累積的令牌量。\n-- Response value local rejected = false local remainToken = 0 這邊就僅附上變數代表的意義，後續說明時會提到這兩個變數。\n   變數名 描述     rejected 是否被拒絕   remainToken 剩餘令牌數量    redis.replicate_commands() local time = redis.call(\u0026#39;TIME\u0026#39;) local currentTime = math.floor(time[1] * 1000 + time[2] / 1000) local modified = false local lastRemainToken = redis.call(\u0026#39;GET\u0026#39;, valueKey) local lastUpdateTime = false if lastRemainToken == false then lastRemainToken = 0 lastUpdateTime = currentTime - interval else lastUpdateTime = redis.call(\u0026#39;GET\u0026#39;, timestampKey) if lastUpdateTime == false then modified = true lastUpdateTime = currentTime - ((lastRemainToken / limit) * interval) end end redis.replicate_commands(): 在Redis 3.2以前，Lua腳本的撰寫必須都是確定性的，也就是說假設今天有1個master與2個slave instance，那Lua腳本必須在三個instance中都產生相同的結果，所以就會導致一些非確定性的指令不能使用，像是redis.call('TIME')，所以在Redis 3.2後若要使用非確定性指令的話需要調用此函數。Redis 5後已將腳本效果複製模式設為默認，因此不需要顯式調用)\n首先我們要取得現在時間(ms)，這邊的redis.call('TIME')會回傳兩個值回來，一個是Unix timestamp(以秒為單位)一個是當前時間(微秒)，所以當前時間戳(以毫秒為單位)計算公式是math.floor(time[1] * 1000 + time[2] / 1000)。\n接下來需要取得上次剩餘的令牌量，那這會有兩種情況\n 無法取得上次剩餘的令牌量: 將上次剩餘的令牌量設為0，並且將上次更新時間設為現在時間減去過期時間(這樣剛好在下一個動作會將其令牌桶補滿) 可以取得上次剩餘的令牌量: 取得上次令牌量後再取得上次更新時間，如果無法取得上次更新時間的話，通常是timestampKey過期但valueKey沒過期，因此需要回推上次更新時間，其計算方式為: 現在時間 - ((剩餘令牌 / 令牌桶最大限制) * 時間區段  -- feedbackToken: max((現在時間 - 過去時間) / 時間間隔 * 最大限制數量, 0) local feedbackToken = math.max((currentTime - lastUpdateTime) / interval * limit, 0) local token = math.min(lastRemainToken + feedbackToken, limit) remainToken = token - batchSize if remainToken \u0026lt; 0 then rejected = true remainToken = token end if rejected == false then redis.call(\u0026#39;PSETEX\u0026#39;, valueKey, interval, remainToken) if feedbackToken \u0026gt; 0 or modified then redis.call(\u0026#39;PSETEX\u0026#39;, timestampKey, interval, currentTime) else redis.call(\u0026#39;PEXPIRE\u0026#39;, timestampKey, interval) end end return { rejected, remainToken } 接下來要計算回饋令牌，也就是從上次存取時間到目前時間累積的令牌量，計算完後需要判斷當前令牌有沒有滿出令牌桶，若滿出則丟棄令牌。\n計算完當前令牌剩餘數量後判斷減去batchSize後是否還大於等於0，若小於0代表拒絕這此請求，最後再設置當前剩餘令牌數量及其過期時間及延長/設置上次更新時間及其過期時間。\n測試結果 最後附上測試結果(使用apache bench): 可以看到傳送了1200個Request，僅有1000個請求被允許(剩餘200個全都拋出429 Too Many Request)。\n","permalink":"https://yurepo.github.io/2021/03/golang-redis-ratelimiter/","summary":"令牌桶演算法實現 前言 這幾天將令牌桶限流演算法使用gin + redis實現了，主要來講是整個限流過程是如何運作的。\nGithub連結\n主要定義了四個文件\n   文件名 描述     dto.go 定義及宣告Ratelimiter的基本結構與核心Take()方法   err.go 定義了一些錯誤   ratelimiter.go 存放gin middleware中驗證的邏輯   script.go 存放 lua 腳本及 lua 腳本中輸入變數的結構    我們會將上次更新的時間與剩餘令牌的數量儲存在Redis中，而主要更新的邏輯會寫在script.go，這裡會發現整個操作Redis資料庫的邏輯是使用lua script去實作的，把多個操作Redis的指令包在lua script中，Redis會保證lua script中的多個操作會以Atomic的方式進行，這樣才可以保證每個操作之間不會有競爭情況(Race Condition)發生。 參考資料\n程式碼部分 Golang 接下來就進入到程式碼的部分 首先我定義了 RedisRateLimiter 結構\ndto.go\ntype RedisRateLimiter struct { context context.Context scriptSHA1 string client *redis.Client } 這邊將RedisRateLimiter的一些必須用到的變數包裝起來，包裝的變數型別包含了Redis客戶端、LUA Script SHA1(後續會使用evalsha調用已經讀進Redis腳本緩存的Lua script)、Goroutine context。\n這個Repository實現的演算法是Token Bucket演算法，不過也可以利用上述定義的結構去實現不同算法，例如：Leaky Bucket。","title":"Golang Redis Ratelimiter"},{"content":"上回我們說了SecurityContextHolder主要在做什麼，這回主要討論的是，SecurityContext到底是何方神聖，它從何而來。\nSecurityContext它作為 Spring Security 核心中的一部分，它的作用可說是非常重要的。我們來看看SecurityContext的源碼。\npublic interface SecurityContext extends Serializable { /** * 獲取當前已驗證的身分或驗證請求令牌 * * @return the \u0026lt;code\u0026gt;Authentication\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; if no authentication * information is available */ Authentication getAuthentication(); /** * 改變目前已驗證的身分或刪除驗證資料 * * @param authentication the new \u0026lt;code\u0026gt;Authentication\u0026lt;/code\u0026gt; token, or * \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; if no further authentication information should be stored */ void setAuthentication(Authentication authentication); } 可以看到SecurityContext主要是在管理Authentication的物件，那這個Authentication主要是存放當前使用者的身分(廢話)、存放是否已驗證以及取得目前使用者擁有的權限。\n那 SecurityContext 從何而來呢? 同個包內的SecurityContextImpl就是它的實現，裡面都是很基本的邏輯，這次就不放了，可從官方GitHub找到相關源代碼。\n那如何在不同request之間保存SecurityContext呢? 在Spring Security主要有兩個在不同request之間保存SecurityContext的策略，這邊簡單介紹一下，兩者都是ServerSecurityContextRepository的實現。\n NoOpServerSecurityContextRepository: 很廢，當你叫它保存的時候它不會理你，左耳進右耳出，然後你問他那個東西在哪，它會直接說\u0026quot;我不知道，你有跟我講過嗎?\u0026quot;，通常用於無狀態(Stateless)驗證，例如：httpBasic。 WebSessionServerSecurityContextRepository: 好學生，你叫它保存的時候，它會幫你做三件事，1. 取得當前Session -\u0026gt; 2. 幫你把東西保存至Session -\u0026gt; 3. 順便幫你把SessionId換成新的。通常用於formLogin。  雖然第二種方法非常理想，可是要知道儲存是非常昂貴的一件事，所以在InMemoryWebSessionStore有定義說，Session預設就只能有10000個，再多它就會跟你鬧脾氣(丟錯誤)。 當然你可以改變預設值使其達到你預估的數量，但最好的解決方法是自定義你的WebSessionStore用以支持更多Session。(在DefaultWebSessionManager可設置您的自定義WebSessionStore)。\n這回我們簡單介紹了SecurityContext以及提了一些相關的API，下回預計介紹各種Filters。\n","permalink":"https://yurepo.github.io/2020/10/spring-security-02-security-context-%E5%BE%9E%E5%93%AA%E4%BE%86/","summary":"上回我們說了SecurityContextHolder主要在做什麼，這回主要討論的是，SecurityContext到底是何方神聖，它從何而來。\nSecurityContext它作為 Spring Security 核心中的一部分，它的作用可說是非常重要的。我們來看看SecurityContext的源碼。\npublic interface SecurityContext extends Serializable { /** * 獲取當前已驗證的身分或驗證請求令牌 * * @return the \u0026lt;code\u0026gt;Authentication\u0026lt;/code\u0026gt; or \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; if no authentication * information is available */ Authentication getAuthentication(); /** * 改變目前已驗證的身分或刪除驗證資料 * * @param authentication the new \u0026lt;code\u0026gt;Authentication\u0026lt;/code\u0026gt; token, or * \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; if no further authentication information should be stored */ void setAuthentication(Authentication authentication); } 可以看到SecurityContext主要是在管理Authentication的物件，那這個Authentication主要是存放當前使用者的身分(廢話)、存放是否已驗證以及取得目前使用者擁有的權限。\n那 SecurityContext 從何而來呢? 同個包內的SecurityContextImpl就是它的實現，裡面都是很基本的邏輯，這次就不放了，可從官方GitHub找到相關源代碼。\n那如何在不同request之間保存SecurityContext呢? 在Spring Security主要有兩個在不同request之間保存SecurityContext的策略，這邊簡單介紹一下，兩者都是ServerSecurityContextRepository的實現。\n NoOpServerSecurityContextRepository: 很廢，當你叫它保存的時候它不會理你，左耳進右耳出，然後你問他那個東西在哪，它會直接說\u0026quot;我不知道，你有跟我講過嗎?\u0026quot;，通常用於無狀態(Stateless)驗證，例如：httpBasic。 WebSessionServerSecurityContextRepository: 好學生，你叫它保存的時候，它會幫你做三件事，1.","title":"Spring Security 02 - Security Context? 從哪來?"},{"content":"Spring Security對於寫過Spring Boot的人應該是再熟悉不過了，這篇文主要紀錄我對於 ReactiveSecurityContextHolder的理解，原始碼版本為5.4.0-RC1。\n在聊原始碼前，我想先聊一下Context到底是什麼。\nContext，中文譯作「上下文」，我對於上下文的理解就是物件作用的環境。\n打個比方，假設現在有一個物件叫做Weather，而假設Weather物件會有下雨、晴朗這兩種狀態，且EarthContext封裝其物件或者是強制其改變為某種狀態時，則可以說Weather的上下文是EarthContext。\n對於Spring Security來說，SecurityContext就是整個Spring Security應用的上下文。\n而SecurityContextHolder就是單純保存這個上下文而存在的。 在傳統Servlet應用SecurityContextHolder是存在多種保存上下文的策略，比方說GlobalSecurityContextHolderStrategy、InheritableThreadLocalSecurityContextHolderStrategy跟ThreadLocalSecurityContextHolderStrategy，但在ReactiveSecurityContextHolder中，並沒有多種策略去保存SecurityContext，唯一保存上下文的方法就是透過Reactor的上下文。\n以下為個人部分翻譯的源碼：\npublic class ReactiveSecurityContextHolder { private static final Class\u0026lt;?\u0026gt; SECURITY_CONTEXT_KEY = SecurityContext.class; /** * 從 Reactor {@link Context} 取得 {@code Mono\u0026lt;SecurityContext\u0026gt;} * @return 回傳 {@code Mono\u0026lt;SecurityContext\u0026gt;} */ public static Mono\u0026lt;SecurityContext\u0026gt; getContext() { // 從Reactor的上下文中取得SecurityContext \treturn Mono.subscriberContext() .filter( c -\u0026gt; c.hasKey(SECURITY_CONTEXT_KEY)) .flatMap( c-\u0026gt; c.\u0026lt;Mono\u0026lt;SecurityContext\u0026gt;\u0026gt;get(SECURITY_CONTEXT_KEY)); } /** * 從 Reactor {@link Context} 清除 {@code Mono\u0026lt;SecurityContext\u0026gt;} * @return 清除Reactor上下文，並回傳一個 Mono\u0026lt;Void\u0026gt;，若清除失敗，則報錯。 */ public static Function\u0026lt;Context, Context\u0026gt; clearContext() { // 從Reactor的上下文中刪除SecurityContext \treturn context -\u0026gt; context.delete(SECURITY_CONTEXT_KEY); } /** * 創建含有 {@code Mono\u0026lt;SecurityContext\u0026gt;} 的 Reactor {@link Context} * 可與其他 {@link Context} 合併 * @param securityContext the {@code Mono\u0026lt;SecurityContext\u0026gt;} to set in the returned * Reactor {@link Context} * @return a Reactor {@link Context} that contains the {@code Mono\u0026lt;SecurityContext\u0026gt;} */ public static Context withSecurityContext(Mono\u0026lt;? extends SecurityContext\u0026gt; securityContext) { return Context.of(SECURITY_CONTEXT_KEY, securityContext); } /** * A shortcut for {@link #withSecurityContext(Mono)} * @param authentication the {@link Authentication} to be used * @return a Reactor {@link Context} that contains the {@code Mono\u0026lt;SecurityContext\u0026gt;} */ public static Context withAuthentication(Authentication authentication) { return withSecurityContext(Mono.just(new SecurityContextImpl(authentication))); } } 了解了 ReactiveSecurityContextHolder 主要在幹嘛，下一篇預計會介紹 SecurityContext 從何而來。\n","permalink":"https://yurepo.github.io/2020/10/spring-security-01-%E9%97%9C%E6%96%BC-reactivesecuritycontextholder-%E7%9A%84%E4%B8%80%E5%85%A9%E4%BB%B6%E4%BA%8B/","summary":"Spring Security對於寫過Spring Boot的人應該是再熟悉不過了，這篇文主要紀錄我對於 ReactiveSecurityContextHolder的理解，原始碼版本為5.4.0-RC1。\n在聊原始碼前，我想先聊一下Context到底是什麼。\nContext，中文譯作「上下文」，我對於上下文的理解就是物件作用的環境。\n打個比方，假設現在有一個物件叫做Weather，而假設Weather物件會有下雨、晴朗這兩種狀態，且EarthContext封裝其物件或者是強制其改變為某種狀態時，則可以說Weather的上下文是EarthContext。\n對於Spring Security來說，SecurityContext就是整個Spring Security應用的上下文。\n而SecurityContextHolder就是單純保存這個上下文而存在的。 在傳統Servlet應用SecurityContextHolder是存在多種保存上下文的策略，比方說GlobalSecurityContextHolderStrategy、InheritableThreadLocalSecurityContextHolderStrategy跟ThreadLocalSecurityContextHolderStrategy，但在ReactiveSecurityContextHolder中，並沒有多種策略去保存SecurityContext，唯一保存上下文的方法就是透過Reactor的上下文。\n以下為個人部分翻譯的源碼：\npublic class ReactiveSecurityContextHolder { private static final Class\u0026lt;?\u0026gt; SECURITY_CONTEXT_KEY = SecurityContext.class; /** * 從 Reactor {@link Context} 取得 {@code Mono\u0026lt;SecurityContext\u0026gt;} * @return 回傳 {@code Mono\u0026lt;SecurityContext\u0026gt;} */ public static Mono\u0026lt;SecurityContext\u0026gt; getContext() { // 從Reactor的上下文中取得SecurityContext \treturn Mono.subscriberContext() .filter( c -\u0026gt; c.hasKey(SECURITY_CONTEXT_KEY)) .flatMap( c-\u0026gt; c.\u0026lt;Mono\u0026lt;SecurityContext\u0026gt;\u0026gt;get(SECURITY_CONTEXT_KEY)); } /** * 從 Reactor {@link Context} 清除 {@code Mono\u0026lt;SecurityContext\u0026gt;} * @return 清除Reactor上下文，並回傳一個 Mono\u0026lt;Void\u0026gt;，若清除失敗，則報錯。 */ public static Function\u0026lt;Context, Context\u0026gt; clearContext() { // 從Reactor的上下文中刪除SecurityContext \treturn context -\u0026gt; context.","title":"Spring Security 01 - 關於 ReactiveSecurityContextHolder 的一兩件事"},{"content":"使用Spring WebFlux保護您的網站應用(驗證篇) 相信瀏覽到這個Topic的各位一定都對 Reactive 有相當的認識了，本文章將專注在講解 WebFlux \u0026amp; Reactive Security的應用開發，其餘基礎便不再贅述。\n首先我們需要到 Spring Initializr 產生我們的Spring WebFlux Application。\n本文章需要的依賴有：Spring Reactive Web、Spring Security、Spring Configuration Processor(可選) *文章撰寫時 Spring 版本為 2.4.0(M2)，依據版本更新有些地方會稍稍不同。 接下來使用您喜歡的IDE去做開發，本文將使用Intellij IDEA開發\n前置準備 首先先添加Jwt的依賴，我們會於稍後用到。(這部分採用您熟悉的工具也行，也不一定需要用Jwt，PASETO也是不錯的選擇)\ndependencies { // jwt dependency implementation(\u0026quot;com.auth0:java-jwt:3.10.3\u0026quot;) // other depencies ... } 設定網站端點 這部分我們需要配置Spring Security，與以往的Servlet應用不同，不能直接繼承WebSecurityConfigurerAdapter去做設定。 首先，在專案底下新增一Packageauth，把所有驗證、授權邏輯放在這。 在auth資料夾底下再新增一個Packageconfig，標示其為設定檔所在位置。 在config底下新增一類別稱作AuthSecurityConfig。 在AuthSecurityConfig新增以下程式碼規劃網站授權的Endpoints\n@Bean fun authRoute(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // csrf 關閉，方便測試  csrf { disable() } // 只篩選/auth開頭的路徑  securityMatcher(PathPatternParserServerWebExchangeMatcher(\u0026#34;/auth/**\u0026#34;)) // 規劃Endpoints  authorizeExchange { authorize(\u0026#34;/auth/login\u0026#34;, permitAll) authorize(\u0026#34;/auth/me\u0026#34;, authenticated) authorize(anyExchange, authenticated) } // 關閉 formLogin跟HttpBasic  formLogin { disable() } httpBasic { disable() } } } 規劃完後要思考一件事情，【要如何驗證使用者傳來的資訊?】，這時候AuthenticationWebFilter就派上用場了，使用者傳Request進來後會經過層層的過濾器，這個結構稱為FilterChain，那鏈狀結構就有一個特色，就是會依序去篩選Request，最後通過層層過濾器的Request才會到達我們的Controller，AuthenticationWebFilter是SecurityFilterChain的其中一環，但未在 Spring Security Reference Docs 有詳細介紹。\n建立AuthenticationManager 在建立AuthenticationFilter前，我們需要能夠集中管理授權的管理者，在Spring Security裡被稱為AuthenticationManager，同時我們也需要UserDetailService才能去初始化AuthenticationMananger，這邊採用MapReactiveUserDetailsService當作範例，實務開發上請串接MongoDB、MySQL等等的資料庫。\n@Bean @Qualifier(\u0026#34;AuthUserService\u0026#34;) fun UserService(): MapReactiveUserDetailsService { val user = User.withDefaultPasswordEncoder() .username(\u0026#34;user\u0026#34;) .password(\u0026#34;pass\u0026#34;) .roles(\u0026#34;USER\u0026#34;) .build() return MapReactiveUserDetailsService(user) } @Bean fun AuthManager( @Qualifier(\u0026#34;AuthUserService\u0026#34;) service: MapReactiveUserDetailsService ): UserDetailsRepositoryReactiveAuthenticationManager { return UserDetailsRepositoryReactiveAuthenticationManager(service) } 建立第一個AuthenticationWebFilter 前置準備都弄好了，接下來就要建立第一個AuthenticationWebFilter，AuthenticationWebFilter已經實現了基礎的驗證，故我們只需要稍作修改即可以使用。 這邊我們會將DataBuffer映射為Object，故將使用ObjectMapper，請添加依賴：\ndependencies { // object mapper implementation(\u0026quot;com.fasterxml.jackson.module:jackson-module-kotlin\u0026quot;) // other depencies ... } 以下是本人寫的AuthenticationWebFilter的範例程式碼，不能夠直接使用，也請不要直接使用，會有安全上的疑慮。 JwtService請自行實現\n@Qualifier(\u0026#34;Authentication\u0026#34;) @Bean fun AuthFilter(manager: UserDetailsRepositoryReactiveAuthenticationManager): AuthenticationWebFilter { // 要被驗證的使用者  var AuthUser: LogInRequest? = null val filter = AuthenticationWebFilter(manager) filter.setRequiresAuthenticationMatcher { ServerWebExchangeMatchers.pathMatchers(HttpMethod.POST, \u0026#34;/auth/login\u0026#34;).matches(it) } filter.setServerAuthenticationConverter {exchange -\u0026gt; exchange.request .body .next() .switchIfEmpty { Mono.defer { Mono.error\u0026lt;DataBuffer\u0026gt;(RequestBodyIsEmpty()) } } .flatMap { it.ToRead\u0026lt;LogInRequest\u0026gt;() } .filter { it.username != null \u0026amp;\u0026amp; it.password != null } .switchIfEmpty { Mono.defer { Mono.error\u0026lt;LogInRequest\u0026gt;(UserInfoError()) } } .map { user -\u0026gt; // 儲存使用者資訊，以便頒發Jwt  AuthUser = user UsernamePasswordAuthenticationToken(user.username, user.password) } } filter.setAuthenticationSuccessHandler { filters, auth -\u0026gt; val credential = AuthUser?.let { it.password } if (credential != null){ return@setAuthenticationSuccessHandler filters.exchange.response.let { it.headers.contentType = MediaType.APPLICATION_JSON it.statusCode = HttpStatus.OK it.writeJson(LogInResponse( token = \u0026#34;${JwtService.prefix}${JwtService.encrypt(auth.name, credential, auth.authorities)}\u0026#34;, expiredAt = JwtService.expireTime().format() )) } } else { return@setAuthenticationSuccessHandler filters.exchange.response.let { it.headers.contentType = MediaType.APPLICATION_JSON it.statusCode = HttpStatus.UNAUTHORIZED it.writeJson(FailResponse( message = \u0026#34;Illegal Arg.\u0026#34; )) } } } filter.setAuthenticationFailureHandler { filters, exception -\u0026gt; AuthUser = null return@setAuthenticationFailureHandler filters.exchange.response.let { it.statusCode = HttpStatus.UNAUTHORIZED it.headers.contentType = MediaType.APPLICATION_JSON it.writeJson(FailResponse(message = exception.message ?: \u0026#34;null\u0026#34;)) } } return filter } 加入Filter至SecurityConfig 我們剛才完成了產生Jwt的Filter，現在則是需要加入Filter至SecurityConfig讓其成為FilterChain的一環，這裡因為我們後面還需要有驗證Jwt的Filter，所以將這個過濾器的次序設為HTTP_BASIC(比AUTHENTICATION前面)\n@Bean fun authRoute(http: ServerHttpSecurity, @Qualifier(\u0026#34;Authentication\u0026#34;) AuthFilter: AuthenticationWebFilter ): SecurityWebFilterChain { return http { // csrf 關閉，方便測試  csrf { disable() } // 只篩選/auth開頭的路徑  securityMatcher(PathPatternParserServerWebExchangeMatcher(\u0026#34;/auth/**\u0026#34;)) // 規劃Endpoints  authorizeExchange { authorize(\u0026#34;/auth/login\u0026#34;, permitAll) authorize(\u0026#34;/auth/me\u0026#34;, authenticated) authorize(anyExchange, authenticated) } // 關閉 formLogin跟HttpBasic  formLogin { disable() } httpBasic { disable() } addFilterAt(AuthFilter, SecurityWebFiltersOrder.HTTP_BASIC) } } 建立驗證Jwt的Filter 與前面大同小異，故直接貼上範例代碼\n@Qualifier(\u0026#34;Validation\u0026#34;) @Bean fun ValidFilter(manager: UserDetailsRepositoryReactiveAuthenticationManager) : AuthenticationWebFilter{ val filter = AuthenticationWebFilter(manager) filter.setServerAuthenticationConverter { exchange -\u0026gt; Mono.just(exchange.request) .flatMap { JwtService.extract(it) } .flatMap { JwtService.parse(it) } .flatMap { JwtService.decrypt(it) } .flatMap { UsernamePasswordAuthBuilder.create(it) } .onErrorResume { exception -\u0026gt; log.info(\u0026#34;Jwt Service Authentication failed...\u0026#34;) Mono.empty\u0026lt;Authentication\u0026gt;() } } return filter } 一樣要將Filter加入至SecurityConfig\n@Bean fun authRoute(http: ServerHttpSecurity, @Qualifier(\u0026#34;Authentication\u0026#34;) AuthFilter: AuthenticationWebFilter, @Qualifier(\u0026#34;Validation\u0026#34;) ValidFilter: AuthenticationWebFilter ): SecurityWebFilterChain { return http { // csrf 關閉，方便測試  csrf { disable() } // 只篩選/auth開頭的路徑  securityMatcher(PathPatternParserServerWebExchangeMatcher(\u0026#34;/auth/**\u0026#34;)) // 規劃Endpoints  authorizeExchange { authorize(\u0026#34;/auth/login\u0026#34;, permitAll) authorize(\u0026#34;/auth/me\u0026#34;, authenticated) authorize(anyExchange, authenticated) } // 關閉 formLogin跟HttpBasic  formLogin { disable() } httpBasic { disable() } addFilterAt(AuthFilter, SecurityWebFiltersOrder.HTTP_BASIC) addFilterAt(ValidFilter, SecurityWebFiltersOrder.AUTHENTICATION) } } 最後做一下單元測試就好了，logout的部分找時間再做說明，基本概念就是讓Jwt Token被invalidate掉，但這樣就要牽涉到資料庫了。\n","permalink":"https://yurepo.github.io/2020/09/spring-webflux-%E6%87%89%E7%94%A8%E9%96%8B%E7%99%BC/","summary":"使用Spring WebFlux保護您的網站應用(驗證篇) 相信瀏覽到這個Topic的各位一定都對 Reactive 有相當的認識了，本文章將專注在講解 WebFlux \u0026amp; Reactive Security的應用開發，其餘基礎便不再贅述。\n首先我們需要到 Spring Initializr 產生我們的Spring WebFlux Application。\n本文章需要的依賴有：Spring Reactive Web、Spring Security、Spring Configuration Processor(可選) *文章撰寫時 Spring 版本為 2.4.0(M2)，依據版本更新有些地方會稍稍不同。 接下來使用您喜歡的IDE去做開發，本文將使用Intellij IDEA開發\n前置準備 首先先添加Jwt的依賴，我們會於稍後用到。(這部分採用您熟悉的工具也行，也不一定需要用Jwt，PASETO也是不錯的選擇)\ndependencies { // jwt dependency implementation(\u0026quot;com.auth0:java-jwt:3.10.3\u0026quot;) // other depencies ... } 設定網站端點 這部分我們需要配置Spring Security，與以往的Servlet應用不同，不能直接繼承WebSecurityConfigurerAdapter去做設定。 首先，在專案底下新增一Packageauth，把所有驗證、授權邏輯放在這。 在auth資料夾底下再新增一個Packageconfig，標示其為設定檔所在位置。 在config底下新增一類別稱作AuthSecurityConfig。 在AuthSecurityConfig新增以下程式碼規劃網站授權的Endpoints\n@Bean fun authRoute(http: ServerHttpSecurity): SecurityWebFilterChain { return http { // csrf 關閉，方便測試  csrf { disable() } // 只篩選/auth開頭的路徑  securityMatcher(PathPatternParserServerWebExchangeMatcher(\u0026#34;/auth/**\u0026#34;)) // 規劃Endpoints  authorizeExchange { authorize(\u0026#34;/auth/login\u0026#34;, permitAll) authorize(\u0026#34;/auth/me\u0026#34;, authenticated) authorize(anyExchange, authenticated) } // 關閉 formLogin跟HttpBasic  formLogin { disable() } httpBasic { disable() } } } 規劃完後要思考一件事情，【要如何驗證使用者傳來的資訊?","title":"Spring WebFlux 應用開發"},{"content":"歌曲連結[Youtube Music]\nさよならを置いて僕に花もたせ 拋下一句再見就離開的妳為我留下了一朵花 覚束ぬままに夜が明けて 在沒有意識的情況下迎來了黎明 誰もいない部屋で起きた 於空無一人的房間裡醒來的我 その温もり一つ残して 身旁僅殘留一絲溫暖 昨日の夜のことは少しも覚えてないけれど 雖然一點也記不起來昨天晚上發生過的事情 他に誰かが居た、そんな気がただしている 也只是感覺昨晚似乎還有誰在的樣子 二日酔いが残る頭は回っちゃいないけれど 雖然腦袋還因為宿醉而無法好好運作 わからないままでもまぁ、それはそれでも綺麗だ 但是如果就這樣記不起來的話、也倒是有其美麗之處 洗面台の歯ブラシ、誰かのコップ、棚の化粧水 洗手台上的牙刷、不知道是誰的杯子、架子上的化妝水 覚えのない物ばかりだ 看到的盡是些沒有印象的物品 枕は花の匂いがする 枕頭上傳來了花的香味 さよならを置いて僕に花もたせ 拋下一句再見就離開的妳為我留下了一朵花 覚束ぬままに夜が明けて 在沒有意識的情況下迎來了黎明 誰もいない部屋で起きる 於空無一人的房間裡醒來的我 その温もり一つ残して 身旁僅殘留一絲溫暖 昨日の夜のことはそこまで覚えてないけれど 雖然記不清楚昨天晚上發生過的事情 美人局を疑う、そんな気もしないでいる 也懷疑過是一場仙人跳，但卻沒有那種感覺 二日酔いも醒めた頭で考えていたけど 儘管已經用宿醉過後的腦袋思考過了 わからないままでもいい 但卻覺得就這樣想不起來也不錯 むしろその方がいい 倒不如說這樣才是最好的 窓際咲くラベンダー、汚れたシンク、編み掛けのマフラー 窗邊盛開的薰衣草、骯髒的水槽、編織後掛著的圍巾 覚えのない事ばかりだ 想起來的淨是一些不記得的事情 部屋には春の匂いがする 房間裡飄散著春天的氣息 浮雲掴むような花人局 仿佛抓住浮雲一般的花人局 誰も来ないまま日が暮れて 等不到誰的回來，就這樣天色漸漸暗下 夕陽の差した窓一つ 只留下一扇照進夕陽餘暉的窗戶 何も知らない僕を残して 和一無所知的我 昨日の夜のことも本当は少し覚えてるんだ 昨天晚上發生過的事情其實還記得一些 貴方の居ない暮らし、それが続くことも 沒有了妳的生活、還是會繼續生活下去 今でもこの頭一つで考えているばかり 至今還是一股腦地去想著 花一つ持たせて消えた貴方のこと 留下一朵花後消逝的妳的事情 明日にはきっと戻ってくる 明天妳一定會回來的吧 何気ない顔で帰ってくる 一定會帶著若無其事的表情回來的吧 今にドアが開いて聞こえる 甚至現在把門打開好像就能聽到妳說 ごめんね、遅くなったって 「對不起、我遲到了」 言葉だけをずっと待っている 這樣的話語我一直在等待著 夕焼けをじっと待っている 靜靜地等待著晚霞 忘れてしまう前に花描け 在忘卻之前把花朵描繪出來吧 今日も一人また夜が来て 今日也是獨自迎來夜晚 誰もいない部屋で眠る 我能在空無一人的房間裡睡著 その温もり、僕に残して 是因為我還殘存著那份溫暖 馬鹿みたいに愛は花もたせ 把名譽拱手讓人的像笨蛋一樣的愛 この部屋にもまた春が来て 才能讓這個房間再次迎來春天 貴方のいない街を生きる 我能生活在沒有妳的街道上 その温もり、僕に残して 是因為我還殘存著那份溫暖 僕にひとつ、花を残して 給我留下一朵花的那份溫暖 言葉だけをずっと待っている 這樣的話語我一直在等待著 夕焼けをじっと待っている 靜靜地等待著晚霞 可供轉載，標明出處 ","permalink":"https://yurepo.github.io/2020/08/%E3%83%A8%E3%83%AB%E3%82%B7%E3%82%AB-%E8%8A%B1%E4%BA%BA%E5%B1%80%E7%BF%BB%E8%AD%AF/","summary":"歌曲連結[Youtube Music]\nさよならを置いて僕に花もたせ 拋下一句再見就離開的妳為我留下了一朵花 覚束ぬままに夜が明けて 在沒有意識的情況下迎來了黎明 誰もいない部屋で起きた 於空無一人的房間裡醒來的我 その温もり一つ残して 身旁僅殘留一絲溫暖 昨日の夜のことは少しも覚えてないけれど 雖然一點也記不起來昨天晚上發生過的事情 他に誰かが居た、そんな気がただしている 也只是感覺昨晚似乎還有誰在的樣子 二日酔いが残る頭は回っちゃいないけれど 雖然腦袋還因為宿醉而無法好好運作 わからないままでもまぁ、それはそれでも綺麗だ 但是如果就這樣記不起來的話、也倒是有其美麗之處 洗面台の歯ブラシ、誰かのコップ、棚の化粧水 洗手台上的牙刷、不知道是誰的杯子、架子上的化妝水 覚えのない物ばかりだ 看到的盡是些沒有印象的物品 枕は花の匂いがする 枕頭上傳來了花的香味 さよならを置いて僕に花もたせ 拋下一句再見就離開的妳為我留下了一朵花 覚束ぬままに夜が明けて 在沒有意識的情況下迎來了黎明 誰もいない部屋で起きる 於空無一人的房間裡醒來的我 その温もり一つ残して 身旁僅殘留一絲溫暖 昨日の夜のことはそこまで覚えてないけれど 雖然記不清楚昨天晚上發生過的事情 美人局を疑う、そんな気もしないでいる 也懷疑過是一場仙人跳，但卻沒有那種感覺 二日酔いも醒めた頭で考えていたけど 儘管已經用宿醉過後的腦袋思考過了 わからないままでもいい 但卻覺得就這樣想不起來也不錯 むしろその方がいい 倒不如說這樣才是最好的 窓際咲くラベンダー、汚れたシンク、編み掛けのマフラー 窗邊盛開的薰衣草、骯髒的水槽、編織後掛著的圍巾 覚えのない事ばかりだ 想起來的淨是一些不記得的事情 部屋には春の匂いがする 房間裡飄散著春天的氣息 浮雲掴むような花人局 仿佛抓住浮雲一般的花人局 誰も来ないまま日が暮れて 等不到誰的回來，就這樣天色漸漸暗下 夕陽の差した窓一つ 只留下一扇照進夕陽餘暉的窗戶 何も知らない僕を残して 和一無所知的我 昨日の夜のことも本当は少し覚えてるんだ 昨天晚上發生過的事情其實還記得一些 貴方の居ない暮らし、それが続くことも 沒有了妳的生活、還是會繼續生活下去 今でもこの頭一つで考えているばかり 至今還是一股腦地去想著 花一つ持たせて消えた貴方のこと 留下一朵花後消逝的妳的事情 明日にはきっと戻ってくる 明天妳一定會回來的吧 何気ない顔で帰ってくる 一定會帶著若無其事的表情回來的吧 今にドアが開いて聞こえる 甚至現在把門打開好像就能聽到妳說 ごめんね、遅くなったって 「對不起、我遲到了」 言葉だけをずっと待っている 這樣的話語我一直在等待著 夕焼けをじっと待っている 靜靜地等待著晚霞 忘れてしまう前に花描け 在忘卻之前把花朵描繪出來吧 今日も一人また夜が来て 今日也是獨自迎來夜晚 誰もいない部屋で眠る 我能在空無一人的房間裡睡著 その温もり、僕に残して 是因為我還殘存著那份溫暖 馬鹿みたいに愛は花もたせ 把名譽拱手讓人的像笨蛋一樣的愛 この部屋にもまた春が来て 才能讓這個房間再次迎來春天 貴方のいない街を生きる 我能生活在沒有妳的街道上 その温もり、僕に残して 是因為我還殘存著那份溫暖 僕にひとつ、花を残して 給我留下一朵花的那份溫暖 言葉だけをずっと待っている 這樣的話語我一直在等待著 夕焼けをじっと待っている 靜靜地等待著晚霞 可供轉載，標明出處 ","title":"ヨルシカ - 花人局【翻譯】"},{"content":"這幾天在準備上課教材，所以回頭做了一些技藝競賽的歷屆考題 我還記得以前有一題在我高中的時候花了將近幾天在想答案，回去重做發現\u0026hellip;\u0026hellip;\n什麼鬼???不就只是遞迴而已\u0026hellip; 重寫後發現猜想真的是對的，可能當時練習的時候頭腦有點混亂吧，原本是寫了三、四個迴圈在裡面跑，有些數字還會直接當掉不給動只能說當時太笨了\u0026hellip; 希望回去學校教的時候學弟不要太聰明，不然當時的我會站不了檯面阿阿阿。 因為太丟人了程式碼就不放上來了。\n","permalink":"https://yurepo.github.io/2020/08/%E5%9B%9E%E9%A0%AD%E7%9C%8B%E7%95%B6%E5%B9%B4%E6%8A%80%E8%97%9D%E7%AB%B6%E8%B3%BD%E9%A1%8C%E7%9B%AE/","summary":"這幾天在準備上課教材，所以回頭做了一些技藝競賽的歷屆考題 我還記得以前有一題在我高中的時候花了將近幾天在想答案，回去重做發現\u0026hellip;\u0026hellip;\n什麼鬼???不就只是遞迴而已\u0026hellip; 重寫後發現猜想真的是對的，可能當時練習的時候頭腦有點混亂吧，原本是寫了三、四個迴圈在裡面跑，有些數字還會直接當掉不給動只能說當時太笨了\u0026hellip; 希望回去學校教的時候學弟不要太聰明，不然當時的我會站不了檯面阿阿阿。 因為太丟人了程式碼就不放上來了。","title":"回頭看當年技藝競賽題目"},{"content":"題目要求是要輸入一個運算式回傳該運算式的結果 有下列規則\n \u0026ldquo;t\u0026rdquo;，代表為 True \u0026ldquo;f\u0026rdquo;，代表為 False \u0026ldquo;!(expr)\u0026quot;，表示將expr得出的布林值反向 \u0026ldquo;\u0026amp;(expr1,expr2,\u0026hellip;)\u0026quot;，表示將所有expr{num}做AND \u0026ldquo;|(expr1,expr2,\u0026hellip;)\u0026quot;，表示將所有expr{num}做OR  馬上進入程式碼撰寫的部分，主要是以遞迴解決 我的想法應該算蠻差的，效能那些部分都不能強求，所以僅放上來做參考，歡迎底下討論\nclass Solution { companion object{ // 運算子列表  val operator = arrayOf(\u0026#39;!\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;|\u0026#39;) } fun parseBoolExpr(expression: String): Boolean { // 如果運算式為空，回傳 `False`  if (expression.isEmpty()) return false return expr(expression) } fun expr(expression: String): Boolean{ // 如果運算式的首個元素不包含於運算子列表(!、\u0026amp;、|)，回傳 `False`  if (!operator.contains(expression[0])) return false // 取得運算子  val mod = expression[0] // 檢查運算子後的下一個字元是否為 `(`  val optStart = if(expression[1] == \u0026#39;(\u0026#39;) 1 else throw RuntimeException(\u0026#34;not valid pattern\u0026#34;) // 檢查運算式的最後一個字源是否為 `)`  val optEnd = if(expression[expression.lastIndex] == \u0026#39;)\u0026#39;) expression.lastIndex else throw RuntimeException(\u0026#34;not valid pattern\u0026#34;) val arg = arrayListOf\u0026lt;Boolean\u0026gt;() var index = optStart while(index \u0026lt;= optEnd){ // 如果需要遞迴解決  if (operator.contains(expression[index])){ val segStartIndex = index + 1 // 尋找括弧的結束點  val segEndIndex = findPair(expression, segStartIndex) // 遞迴解決並將結果新增到列表中  arg.add(expr(expression.substring(index, segEndIndex))) // 運算完成後略過已經運算完成的運算式  index = segEndIndex + 1 } else{ //不需要遞迴解決的話就直接新增到列表中  when (expression[index]){ \u0026#39;t\u0026#39; -\u0026gt; arg.add(true) \u0026#39;f\u0026#39; -\u0026gt; arg.add(false) } index++ } } return calculartor(mod, arg).apply { println(\u0026#34;matching $expressionresult: $this\u0026#34;) } } fun findPair(expr: String, startIndex: Int): Int{ var pass = 0 expr.substring(startIndex).forEachIndexed { index, item -\u0026gt; when(item){ \u0026#39;(\u0026#39; -\u0026gt; pass++ \u0026#39;)\u0026#39; -\u0026gt; pass-- } if (item == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; pass == 0){ return index + startIndex + 1 } } return -1 } fun calculartor(mod: Char, list: List\u0026lt;Boolean\u0026gt;): Boolean { when(mod){ \u0026#39;!\u0026#39; -\u0026gt; { return !list[0] } \u0026#39;\u0026amp;\u0026#39; -\u0026gt; { return !list.contains(false) } \u0026#39;|\u0026#39; -\u0026gt; { return list.contains(true) } } return false } } ","permalink":"https://yurepo.github.io/2020/08/parsing-a-boolean-expression/","summary":"題目要求是要輸入一個運算式回傳該運算式的結果 有下列規則\n \u0026ldquo;t\u0026rdquo;，代表為 True \u0026ldquo;f\u0026rdquo;，代表為 False \u0026ldquo;!(expr)\u0026quot;，表示將expr得出的布林值反向 \u0026ldquo;\u0026amp;(expr1,expr2,\u0026hellip;)\u0026quot;，表示將所有expr{num}做AND \u0026ldquo;|(expr1,expr2,\u0026hellip;)\u0026quot;，表示將所有expr{num}做OR  馬上進入程式碼撰寫的部分，主要是以遞迴解決 我的想法應該算蠻差的，效能那些部分都不能強求，所以僅放上來做參考，歡迎底下討論\nclass Solution { companion object{ // 運算子列表  val operator = arrayOf(\u0026#39;!\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;|\u0026#39;) } fun parseBoolExpr(expression: String): Boolean { // 如果運算式為空，回傳 `False`  if (expression.isEmpty()) return false return expr(expression) } fun expr(expression: String): Boolean{ // 如果運算式的首個元素不包含於運算子列表(!、\u0026amp;、|)，回傳 `False`  if (!operator.contains(expression[0])) return false // 取得運算子  val mod = expression[0] // 檢查運算子後的下一個字元是否為 `(`  val optStart = if(expression[1] == \u0026#39;(\u0026#39;) 1 else throw RuntimeException(\u0026#34;not valid pattern\u0026#34;) // 檢查運算式的最後一個字源是否為 `)`  val optEnd = if(expression[expression.","title":"Parsing A Boolean Expression"},{"content":"HelloWorld | JVM 因為是部落格上的第一篇，所以想來測試基本語法高亮 首先是Java\n// 測試Java註解 public static void main(string[] args){ System.out.println(\u0026#34;hello world\u0026#34;); } 接下來是Kotlin\nfun main(){ \u0026#34;hello world\u0026#34;.println() } fun String.println(){ println(this) } 最後基本的C語言好了\nint main(){ printf(\u0026#34;hello world\u0026#34;); return 0; } ","permalink":"https://yurepo.github.io/2020/08/helloworld-jvm/","summary":"HelloWorld | JVM 因為是部落格上的第一篇，所以想來測試基本語法高亮 首先是Java\n// 測試Java註解 public static void main(string[] args){ System.out.println(\u0026#34;hello world\u0026#34;); } 接下來是Kotlin\nfun main(){ \u0026#34;hello world\u0026#34;.println() } fun String.println(){ println(this) } 最後基本的C語言好了\nint main(){ printf(\u0026#34;hello world\u0026#34;); return 0; } ","title":"HelloWorld | JVM"}]